@using Datahub.Shared.Entities
@using Datahub.Core.Model.Projects
@using Datahub.Shared
@using Datahub.Core.Services.Projects

@inject IDbContextFactory<DatahubProjectDBContext> _contextFactory
@inject IRequestManagementService _requestManagementService
@inject IUserInformationService _userInformationService
@inject ILogger<WorkspaceToolboxPage> _logger
@inject ISnackbar _snackbar
@inject NavigationManager _navigationManager

@if (_initializing)
{
    <DHLoadingInitializer Message="@Localizer["Loading..."]"/>
    return;
}

<MudStack>
    <DHMainContentTitle Title="@Localizer["Toolbox Catalogue"]"/>
    <MudText>
        @Localizer["The Toolbox Catalogue is a collection of tools that can be added to your workspace. You can add tools to your workspace by clicking on the 'Add to Workspace' button."]
    </MudText>

    <MudDivider Class="my-6"/>
    <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Style="color: #000;" Class="mb-6">
        @Localizer["The \"Add to Workspace\" button will show the state of your tool request after being clicked."]
    </MudAlert>

    @if (_metadataRequired)
    {
        <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined" Style="color: #000;" Class="mb-6">
            @Localizer["The workspace metadata is currently incomplete. No resources can be provisioned until the project metadata has been filled"].
            <MudLink Href="@_metadataUrl">
                @Localizer["Click here to edit the metadata."]
            </MudLink>
        </MudAlert>
    }

    <MudGrid>
        @foreach (var tool in _toolList)
        {
            <MudItem xs="12" sm="6" md="4">
                <MudPaper Outlined Class="pt-4 px-6 pb-6">
                    <MudStack Style="height: 280px;">
                        <MudStack Row AlignItems="AlignItems.Center">
                            <DHIcon Icon="@GetIcon(tool)" Class="mr-2"/>
                            <MudText Typo="Typo.h3">
                                @GetLabel(tool)
                            </MudText>
                        </MudStack>
                        <MudText>
                            @GetDescription(tool)
                        </MudText>
                        <MudSpacer/>
                        <MudStack Row>
                            @{
                                var status = _toolDisplayStatusMap[tool];
                            }
                            @switch (status)
                            {
                                case TerraformStatus.CreateRequested:
                                case TerraformStatus.InProgress:
                                case TerraformStatus.DeleteRequested:
                                    <ToolboxButton Status="@status" Disabled="@true"/>
                                    break;
                                case TerraformStatus.Completed:
                                    <MudStack>
                                        <ToolboxButton Status="@status" Disabled="@true" Icon="fa-light fa-check-to-slot"/>
                                        <DatahubAuthView AuthLevel="DatahubAuthView.AuthLevels.WorkspaceLead" ProjectAcronym="@WorkspaceAcronym">
                                            <DHButton Variant="@Variant.Filled" Color="@Color.Error" OnClick="@(() => NavigateToResourceDeletePage(tool))">
                                                @Localizer["Remove Tool from Workspace"]
                                                <DHIcon Icon="@SidebarIcons.Delete" Class="ml-2" Style="font-size: 0.8rem;"/>
                                            </DHButton>
                                        </DatahubAuthView>
                                    </MudStack>
                                    break;
                                case AvailabilityStatus.Available:
                                    <ToolboxButton Status="@status" Icon="@SidebarIcons.CreateNew" OnClick="@(async () => await AddResourceToWorkspace(tool))"/>
                                    break;
                                case AvailabilityStatus.Disabled:
                                    <ToolboxButton Status="@status" Disabled="@true" Icon="@SidebarIcons.CreateNew"/>
                                    break;
                                case AvailabilityStatus.UnderDevelopment:
                                    <ToolboxButton Status="@status" Disabled="@true" Icon="fa-light fa-space-station-moon-construction"/>
                                    break;
                                case AvailabilityStatus.MetadataRequired:
                                    <ToolboxButton Status="@status" Disabled="@true" Icon="@SidebarIcons.Metadata"/>
                                    break;
                                default:
                                    <ToolboxButton Status="Error" Disabled="@true" />
                                    break;
                            }
                        </MudStack>
                    </MudStack>
                </MudPaper>
            </MudItem>
        }
    </MudGrid>
</MudStack>

@code {

    [Parameter]
    public string WorkspaceAcronym { get; set; }

    private Datahub_Project _workspace;

    private readonly List<string> _toolList =
    [
        TerraformTemplate.AzureDatabricks,
        TerraformTemplate.AzureStorageBlob,
        TerraformTemplate.AzureAppService,
        TerraformTemplate.AzurePostgres,
        TerraformTemplate.AzureArcGis,
        TerraformTemplate.AzureAPI
    ];

    internal record struct AvailabilityStatus
    {
        public const string Available = "Available";
        public const string UnderDevelopment = "Under Development";
        public const string MetadataRequired = "Metadata Required";
        public const string Disabled = "Disabled";
    }

    private readonly Dictionary<string, string> _toolAvailabilityStatusMap = new()
    {
        { TerraformTemplate.AzureDatabricks, AvailabilityStatus.Available },
        { TerraformTemplate.AzureStorageBlob, AvailabilityStatus.Available },
        { TerraformTemplate.AzureAppService, AvailabilityStatus.Available },
        { TerraformTemplate.AzurePostgres, AvailabilityStatus.Available },
        { TerraformTemplate.AzureArcGis, AvailabilityStatus.UnderDevelopment },
        { TerraformTemplate.AzureAPI, AvailabilityStatus.UnderDevelopment }
    };

    private readonly Dictionary<string, string> _toolDisplayStatusMap = new();

    private bool _metadataRequired = true;
    private bool _initializing = true;
    private string _metadataUrl => $"{PageRoutes.WorkspacePrefix}/{WorkspaceAcronym}/{WorkspaceSidebar.SectionViews.Metadata}";

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        await using var context = await _contextFactory.CreateDbContextAsync();
        _workspace = await context.Projects
            .AsNoTracking()
            .Include(w => w.Resources)
            .FirstAsync(w => w.Project_Acronym_CD == WorkspaceAcronym);

        // TODO: Update this piece of code once the metadata is filled in via GC Hosting
        _metadataRequired = _workspace.MetadataAdded != true;
        if (_metadataRequired)
        {
            foreach (var (tool, _) in _toolAvailabilityStatusMap)
            {
                _toolDisplayStatusMap[tool] = AvailabilityStatus.MetadataRequired;
            }
        }
        else
        {
            // loop through the tools and check if they exist
            foreach (var tool in _toolList)
            {
                var resourceStatus = FetchWorkspaceResourceStatus(tool);
                _toolDisplayStatusMap[tool] = resourceStatus;
            }
        }
        
        _initializing = false;
        await InvokeAsync(StateHasChanged);
    }

    private string FetchWorkspaceResourceStatus(string resourceType)
    {
        if (_toolAvailabilityStatusMap[resourceType] != AvailabilityStatus.Available)
        {
            return _toolAvailabilityStatusMap[resourceType];
        }

        var resource = _workspace.Resources
            .FirstOrDefault(r => r.ResourceType == TerraformTemplate.GetTerraformServiceType(resourceType));
        
        if(resource is null)
        {
            return AvailabilityStatus.Available;
        }

        if (resource.Status is not null) return resource.Status;
        
        _logger.LogWarning("Resource {ResourceType} in workspace {WorkspaceAcronym} has no status", resourceType, WorkspaceAcronym);
        // TODO: Add a default status for resources that have no status
        return TerraformStatus.Completed;
    }

    private async Task AddResourceToWorkspace(string resource)
    {
        _logger.LogInformation("Adding tool {Tool} to workspace {WorkspaceAcronym}", resource, WorkspaceAcronym);
        _toolDisplayStatusMap[resource] = TerraformStatus.CreateRequested;
        await InvokeAsync(StateHasChanged);

        try
        {
            var resourceType = TerraformTemplate.GetTerraformServiceType(resource);
            await using var ctx = await _contextFactory.CreateDbContextAsync();
            
            var exists = await ctx.Project_Resources2
                .AnyAsync(r => r.ProjectId == _workspace.Project_ID && r.ResourceType == resourceType);
            
            if (exists)
            {
                _snackbar.Add(Localizer["{0} is already added to your workspace", GetLabel(resource)], Severity.Info);
                return;
            }

            var currentUser = await _userInformationService.GetCurrentPortalUserAsync();
            var template = new TerraformTemplate(resource, TerraformStatus.CreateRequested);
            await _requestManagementService.HandleTerraformRequestServiceAsync(_workspace, template, currentUser);
            _logger.LogInformation("Tool {Tool} successfully added to workspace {WorkspaceAcronym}", resource, WorkspaceAcronym);
            _snackbar.Add(Localizer["{0} successfully added to your workspace", GetLabel(resource)], Severity.Success);
            
            _toolDisplayStatusMap[resource] = TerraformStatus.InProgress;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception e)
        {
            _logger.LogError(e, "Error adding tool {Tool} to workspace {WorkspaceAcronym}", resource, WorkspaceAcronym);
            
            _toolDisplayStatusMap[resource] = TerraformStatus.Failed;
            _snackbar.Add(Localizer["Error adding {0} to your workspace", GetLabel(resource)], Severity.Error);
        }
    }

    private void NavigateToResourceDeletePage(string resourceName)
    {
        _navigationManager.NavigateTo($"{PageRoutes.WorkspacePrefix}/{WorkspaceAcronym}/{WorkspaceSidebar.SectionViews.Delete}/{resourceName}");
    }

    private string GetLabel(string tool)
    {
        return tool switch
        {
            TerraformTemplate.AzureDatabricks => Localizer["Azure Databricks"],
            TerraformTemplate.AzureStorageBlob => Localizer["Azure Storage Blob"],
            TerraformTemplate.AzureAppService => Localizer["Azure App Service"],
            TerraformTemplate.AzurePostgres => Localizer["Azure Postgres"],
            TerraformTemplate.AzureArcGis => Localizer["Azure ArcGIS"],
            TerraformTemplate.AzureAPI => Localizer["Azure API Management"],
            _ => tool
        };
    }

    private string GetDescription(string tool)
    {
        return tool switch
        {
            TerraformTemplate.AzureDatabricks => Localizer["Azure Databricks is a fast, easy, and collaborative Apache Spark-based analytics platform. Accelerate big data analytics and artificial intelligence (AI) solutions with Azure Databricks, a fast, easy and collaborative Apache Spark-based analytics service."],
            TerraformTemplate.AzureStorageBlob => Localizer["Azure Blob storage is Microsoft's object storage solution for the cloud. Blob storage is optimized for storing massive amounts of unstructured data, such as text or binary data."],
            TerraformTemplate.AzureAppService => Localizer["Azure App Service is a fully managed web hosting service for building web apps, mobile back ends, and RESTful APIs. It offers auto-scaling and high availability, supports both Windows and Linux, and enables automated deployments from GitHub, Azure DevOps, or any Git repo."],
            TerraformTemplate.AzurePostgres => Localizer["Azure Database for PostgreSQL is a relational database service based on the open-source Postgres database engine. It's a fully managed database-as-a-service offering that can handle mission-critical workloads with predictable performance, security, high availability, and dynamic scalability."],
            TerraformTemplate.AzureArcGis => Localizer["ArcGIS is a geographic information system (GIS) for working with maps and geographic information. It is used for creating and using maps, compiling geographic data, analyzing mapped information, sharing and discovering geographic information, using maps and geographic information in a range of applications, and managing geographic information in a database."],
            TerraformTemplate.AzureAPI => Localizer["Azure API Management is a fully managed service that enables participants to publish, secure, transform, maintain, and monitor APIs. To use API Management, you must first create an Azure App Service."],
            _ => tool
        };
    }

    private static string GetIcon(string tool)
    {
        return tool switch
        {
            TerraformTemplate.AzureDatabricks => SidebarIcons.Databricks,
            TerraformTemplate.AzureStorageBlob => SidebarIcons.Storage,
            TerraformTemplate.AzureAppService => SidebarIcons.WebApp,
            TerraformTemplate.AzurePostgres => SidebarIcons.SqlDatabase,
            TerraformTemplate.AzureArcGis => SidebarIcons.ArcGis,
            TerraformTemplate.AzureAPI => SidebarIcons.Api,
            _ => SidebarIcons.Default
        };
    }

}