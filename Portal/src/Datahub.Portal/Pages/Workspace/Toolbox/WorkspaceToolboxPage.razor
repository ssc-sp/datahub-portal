@using Datahub.Application.Services
@using Datahub.Application.Services.UserManagement
@using Datahub.Shared.Entities
@using Datahub.Core.Model.Projects
@using Datahub.Shared
@using Datahub.Core.Services.Projects
@using Datahub.Application.Services.Notifications

@inject IDbContextFactory<DatahubProjectDBContext> _contextFactory
@inject IRequestManagementService _requestManagementService
@inject IUserInformationService _userInformationService
@inject ILogger<WorkspaceToolboxPage> _logger
@inject ISnackbar _snackbar
@inject NavigationManager NavigationManager
@inject IDatahubEmailService _emailService
@inject IResourceMessagingService _resourceMessagingService
@inject DatahubPortalConfiguration _datahubPortalConfiguration

<MudStack>
    <DHMainContentTitle Title="@Localizer["Toolbox Catalogue"]" />
    <MudText>
        @Localizer["The Toolbox Catalogue is a collection of tools that can be added to your workspace. You can add tools to your workspace by clicking on the 'Add to Workspace' button."]
    </MudText>

    <MudDivider Class="my-6"/>
    <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Style="color: #000;" Class="mb-6">
        @Localizer["The \"Add to Workspace\" button will show the state of your tool request after being clicked."]
    </MudAlert>

    @if (_metadataRequired)
    {
        <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined" Style="color: #000;" Class="mb-6">
            @Localizer["The workspace metadata is currently incomplete. No resources can be provisioned until the project metadata has been filled"].
            <MudLink Href="@_metadataUrl">
                @Localizer["Click here to edit the metadata."]
            </MudLink>
        </MudAlert>
    }

    <MudGrid>
        @foreach (var tool in _toolList)
        {
            <MudItem xs="12" sm="6" md="4">
                <MudPaper Outlined Class="pt-4 px-6 pb-6">
                    <MudStack Style="height: 280px;">
                        <MudStack Row AlignItems="AlignItems.Center">
                            <DHIcon Icon="@GetIcon(tool)" Class="mr-2" />
                            <MudText Typo="Typo.h3">
                                @GetLabel(tool)
                            </MudText>
                        </MudStack>
                        <MudText>
                            @GetDescription(tool)
                        </MudText>
                        <MudSpacer/>
                        <MudStack Row>
                            @switch (_toolCurrentDevelopmentStatusMap[tool])
                            {
                                case ProjectResourceStatus.Available:
                                    <DHButton Variant="@Variant.Filled" Color="@Color.Primary" OnClick="@(async () => await AddToolToWorkspace(tool))">
                                        @Localizer["Add Tool to Workspace"]
                                        <DHIcon Icon="@SidebarIcons.CreateNew" Class="ml-2" Style="font-size: 0.8rem;" />
                                    </DHButton>
                                    break;
                                case ProjectResourceStatus.SendingRequest:
                                    <SpinnerButton Variant="@Variant.Filled">
                                        @Localizer["Sending Request..."]
                                    </SpinnerButton>
                                    break;
                                case ProjectResourceStatus.PendingRequest:
                                    <ToolBeingProvisionedButton Variant="@Variant.Filled"/>
                                    break;
                                case ProjectResourceStatus.Exists:
                                    <MudStack>
                                        <DHButton Variant="@Variant.Filled" Color="@Color.Primary" Disabled>
                                            @Localizer["Tool has been created"]
                                            <DHIcon Icon="fa-light fa-check-to-slot" Class="ml-2" Style="font-size: 0.8rem;" />
                                        </DHButton>
                                        <DatahubAuthView AuthLevel="DatahubAuthView.AuthLevels.WorkspaceLead" ProjectAcronym="@WorkspaceAcronym">
                                            <DHButton Variant="@Variant.Filled" Color="@Color.Error" OnClick="@(async () => GoToResourceDeletionPage(tool))">
                                            @Localizer["Remove Tool from Workspace"]
                                            <DHIcon Icon="@SidebarIcons.Delete" Class="ml-2" Style="font-size: 0.8rem;" />
                                        </DHButton>
                                        </DatahubAuthView>
                                    </MudStack>
                                    break;
                                case ProjectResourceStatus.SendingDeletion:
                                    <SpinnerButton Variant="@Variant.Filled">
                                        @Localizer["Deleting Tool..."]
                                    </SpinnerButton>
                                    break;
                                case ProjectResourceStatus.Disabled:
                                    <DHButton Variant="@Variant.Filled" Color="@Color.Primary" Disabled>
                                        @Localizer["Not Enabled"]
                                        <DHIcon Icon="fa-light fa-layer-plus" Class="ml-2" Style="font-size: 0.8rem;" />
                                    </DHButton>
                                    break;
                                case ProjectResourceStatus.UnderDevelopment:
                                    <DHButton Variant="@Variant.Filled" Color="@Color.Primary" Disabled>
                                        @Localizer["Under Development"]
                                        <DHIcon Icon="fa-light fa-space-station-moon-construction" Class="ml-2" Style="font-size: 0.8rem;" />
                                    </DHButton>
                                    break;
                                case ProjectResourceStatus.MetadataRequired:
                                    <DHButton Variant="@Variant.Filled" Color="@Color.Primary" Disabled>
                                        @Localizer["Metadata Required"]
                                        <DHIcon Icon="@SidebarIcons.Metadata" Class="ml-2" Style="font-size: 0.8rem;" />
                                    </DHButton>
                                    break;
                                default:
                                    <DHButton Variant="@Variant.Filled" Color="@Color.Primary" Disabled>
                                        @Localizer["Unknown"]
                                        <DHIcon Icon="fa-light fa-layer-plus" Class="ml-2" Style="font-size: 0.8rem;" />
                                    </DHButton>
                                    break;
                            }
                        </MudStack>
                    </MudStack>
                </MudPaper>
            </MudItem>
        }
    </MudGrid>
</MudStack>

@code {
    [Parameter] public string WorkspaceAcronym { get; set; }

    private Datahub_Project _workspace;

    private readonly List<string> _toolList =
    [
        TerraformTemplate.AzureDatabricks,
    TerraformTemplate.AzureStorageBlob,
    TerraformTemplate.AzureAppService,
    TerraformTemplate.AzurePostgres,
    TerraformTemplate.AzureArcGis,
    TerraformTemplate.AzureAPI
    ];

    // private enum AvailabilityStatus
    // {
    //     Available,
    //     // SendingRequest,
    //     // PendingRequest,
    //     // Disabled,
    //     // PendingDeletion,
    //     UnderDevelopment,
    //     // Exists,
    //     MetadataRequired
    //     // Error
    // }

    private readonly Dictionary<string, ProjectResourceStatus> _toolCurrentDevelopmentStatusMap = new()
    {
        { TerraformTemplate.AzureDatabricks, ProjectResourceStatus.Available },
        { TerraformTemplate.AzureStorageBlob, ProjectResourceStatus.Available },
        { TerraformTemplate.AzureAppService, ProjectResourceStatus.Available },
        { TerraformTemplate.AzurePostgres, ProjectResourceStatus.Available },
        { TerraformTemplate.AzureArcGis, ProjectResourceStatus.UnderDevelopment },
        { TerraformTemplate.AzureAPI, ProjectResourceStatus.UnderDevelopment }
    };

    private bool _metadataRequired = true;
    private string _metadataUrl => $"{PageRoutes.WorkspacePrefix}/{WorkspaceAcronym}/{WorkspaceSidebar.SectionViews.Metadata}";
    private string _resourceDeletionUrl => $"{PageRoutes.WorkspacePrefix}/{WorkspaceAcronym}/{WorkspaceSidebar.SectionViews.Delete}";

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        await using var context = await _contextFactory.CreateDbContextAsync();
        _workspace = await context.Projects
            .AsNoTracking()
            .Include(w => w.Resources)
            .FirstOrDefaultAsync(w => w.Project_Acronym_CD == WorkspaceAcronym);

        _metadataRequired = _workspace?.MetadataAdded != true;
        if (_metadataRequired)
        {
            foreach (var (tool, _) in _toolCurrentDevelopmentStatusMap)
            {
                _toolCurrentDevelopmentStatusMap[tool] = ProjectResourceStatus.MetadataRequired;
            }
        }
        else
        {
            // loop through the tools and check if they exist
            foreach (var tool in _toolList)
            {
                _toolCurrentDevelopmentStatusMap[tool] = GetToolStatus(tool);
            }
            // checking for deleted tools
            ToolDeletion();
        }
    }

    private async void SetToolStatus(string tool)
    {
        var resourceType = TerraformTemplate.GetTerraformServiceType(tool);
        await using var ctx = await _contextFactory.CreateDbContextAsync();
        var _resourceCheck = await ctx.Project_Resources2.FirstOrDefaultAsync(r => r.ResourceType == resourceType);

        if (_resourceCheck != null)
        {
            _resourceCheck.Status = _toolCurrentDevelopmentStatusMap[tool].ToString();
        }

        await InvokeAsync(StateHasChanged);
    }

    private ProjectResourceStatus GetToolStatus(string tool)
    {
        if (_toolCurrentDevelopmentStatusMap[tool] != ProjectResourceStatus.Available)
        {
            return _toolCurrentDevelopmentStatusMap[tool];
        }

        var toolResource = _workspace.Resources.FirstOrDefault(r => r.ResourceType.EndsWith(tool));
        if (toolResource == null)
        {
            return ProjectResourceStatus.Available;
        }

        if (toolResource.CreatedAt == null)
        {
            return ProjectResourceStatus.PendingRequest;
        }

        if (toolResource.CreatedAt < DateTime.UtcNow)
        {
            return ProjectResourceStatus.Exists;
        }

        return ProjectResourceStatus.Error;
    }

    private async void ToolDeletion()
    {
        await using var ctx = await _contextFactory.CreateDbContextAsync();

        foreach (var tool in _toolList)
        {
            var resourceType = TerraformTemplate.GetTerraformServiceType(tool);
            var _resourceCheck = await ctx.Project_Resources2.FirstOrDefaultAsync(r => r.ResourceType == resourceType);
            if (_resourceCheck != null && _resourceCheck.Status == "SendingDeletion")
            {
                _toolCurrentDevelopmentStatusMap[tool] = GetStatus(_resourceCheck.Status);
                await RemoveToolFromWorkspace(tool);
            }
        }
        await InvokeAsync(StateHasChanged);
    }

    private async Task AddToolToWorkspace(string tool)
    {
        _logger.LogInformation("Adding tool {Tool} to workspace {WorkspaceAcronym}", tool, WorkspaceAcronym);
        _toolCurrentDevelopmentStatusMap[tool] = ProjectResourceStatus.SendingRequest;
        await InvokeAsync(StateHasChanged);

        try
        {
            var resourceType = TerraformTemplate.GetTerraformServiceType(tool);
            await using var ctx = await _contextFactory.CreateDbContextAsync();
            var _resourceCheck = await ctx.Project_Resources2.FirstOrDefaultAsync(r => r.ResourceType == resourceType);
            _resourceCheck.Status = ProjectResourceStatus.PendingRequest.ToString();

            await ctx.SaveChangesAsync();

            var currentUser = await _userInformationService.GetCurrentPortalUserAsync();
            var template = new TerraformTemplate(tool, TerraformStatus.CreateRequested);
            await _requestManagementService.HandleTerraformRequestServiceAsync(_workspace, template, currentUser);
            _logger.LogInformation("Tool {Tool} successfully added to workspace {WorkspaceAcronym}", tool, WorkspaceAcronym);
            _toolCurrentDevelopmentStatusMap[tool] = ProjectResourceStatus.PendingRequest;
            _snackbar.Add(Localizer["{0} successfully added to your workspace", GetLabel(tool)], Severity.Success);
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception e)
        {
            _logger.LogError(e, "Error adding tool {Tool} to workspace {WorkspaceAcronym}", tool, WorkspaceAcronym);
            _toolCurrentDevelopmentStatusMap[tool] = ProjectResourceStatus.Error;
            _snackbar.Add(Localizer["Error adding {0} to your workspace", GetLabel(tool)], Severity.Error);
        }
    }

    private async Task RemoveToolFromWorkspace(string tool)
    {
        _logger.LogInformation("Removing {Tool} from {WorkspaceAcronym}", GetLabel(tool), WorkspaceAcronym);
        _toolCurrentDevelopmentStatusMap[tool] = ProjectResourceStatus.SendingDeletion;
        await InvokeAsync(StateHasChanged);
        try
        {

            var currentUser = await _userInformationService.GetCurrentPortalUserAsync();

            var resourceType = TerraformTemplate.GetTerraformServiceType(tool);
            await using var ctx = await _contextFactory.CreateDbContextAsync();
            var _resourceCheck = await ctx.Project_Resources2.FirstOrDefaultAsync(r => r.ResourceType == resourceType);


            // adding deletion request to queue
            var userEmail = await _userInformationService.GetUserEmail();
            var workspaceDefinition = await _resourceMessagingService.GetWorkspaceDefinition(WorkspaceAcronym, requestingUserEmail: userEmail);
            //await _resourceMessagingService.SendToTerraformDeleteResourceQueue(workspaceDefinition, _workspace.Project_ID, tool);

            _logger.LogInformation("Tool {Tool} successfully removed from workspace {WorkspaceAcronym}", tool, WorkspaceAcronym);
            _toolCurrentDevelopmentStatusMap[tool] = ProjectResourceStatus.Available;
            _snackbar.Add(Localizer["{0} successfully removed from your workspace", GetLabel(tool)], Severity.Success);

            _resourceCheck.Status = ProjectResourceStatus.Available.ToString();

            await HandleSendEmail(tool);

            await ctx.SaveChangesAsync();

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception e)
        {
            _logger.LogError(e, "Error removing tool {Tool} from workspace {WorkspaceAcronym}", tool, WorkspaceAcronym);
            _toolCurrentDevelopmentStatusMap[tool] = ProjectResourceStatus.Error;
            _snackbar.Add(Localizer["Error removing {0} from your workspace", GetLabel(tool)], Severity.Error);
        }
    }

    private async void GoToResourceDeletionPage(string tool)
    {
        var resourceType = TerraformTemplate.GetTerraformServiceType(tool);
        await using var ctx = await _contextFactory.CreateDbContextAsync();
        var _resourceCheck = await ctx.Project_Resources2.FirstOrDefaultAsync(r => r.ResourceType == resourceType);
        _resourceCheck.Status = ProjectResourceStatus.PendingDeletion.ToString();

        await ctx.SaveChangesAsync();
        await InvokeAsync(StateHasChanged);

        NavigationManager.NavigateTo(_resourceDeletionUrl);
    }



    private async Task HandleSendEmail(string tool)
    {
        List<string> recipients = GetProjectAdminsEmails();
        string subject = tool + " deleted from workspace " + WorkspaceAcronym;

        string body = "An admin in your workspace (" + WorkspaceAcronym + ") has deleted the " + tool + " resource.";

        await SendEmailAsync(async () =>
        {
            await _emailService.SendToRecipients(_datahubPortalConfiguration.EmailNotification.SenderAddress, recipients, subject, body);
        });
    }

    private async Task SendEmailAsync(Func<Task> action)
    {
        try
        {
            await action.Invoke();
            _logger.LogInformation("Email sent");
        }
        catch
        {
            _logger.LogInformation("Failed to send the email");
        }
    }

    public List<string> GetProjectAdminsEmails()
    {
        using var ctx = _contextFactory.CreateDbContext();

        return ctx.Project_Users
            .Where(a =>
                a.Project.Project_Acronym_CD == WorkspaceAcronym
                && (a.RoleId == (int)Project_Role.RoleNames.Admin ||
                    a.RoleId == (int)Project_Role.RoleNames.WorkspaceLead)
                && !string.IsNullOrEmpty(a.PortalUser.Email))
            .Select(f => f.PortalUser.Email)
            .ToList();
    }


    
    
    
    private string GetLabel(string tool)
    {
        return tool switch
        {
            TerraformTemplate.AzureDatabricks => Localizer["Azure Databricks"],
            TerraformTemplate.AzureStorageBlob => Localizer["Azure Storage Blob"],
            TerraformTemplate.AzureAppService => Localizer["Azure App Service"],
            TerraformTemplate.AzurePostgres => Localizer["Azure Postgres"],
            TerraformTemplate.AzureArcGis => Localizer["Azure ArcGIS"],
            TerraformTemplate.AzureAPI => Localizer["Azure API Management"],
            _ => tool
        };
    }

    private ProjectResourceStatus GetStatus(string toolStatus)
    {
        return toolStatus switch
        {
            "SendingDeletion" => ProjectResourceStatus.SendingDeletion,
            _ => ProjectResourceStatus.Error
        };
    }

    private string GetDescription(string tool)
    {
        return tool switch
        {
            TerraformTemplate.AzureDatabricks => Localizer["Azure Databricks is a fast, easy, and collaborative Apache Spark-based analytics platform. Accelerate big data analytics and artificial intelligence (AI) solutions with Azure Databricks, a fast, easy and collaborative Apache Spark-based analytics service."],
            TerraformTemplate.AzureStorageBlob => Localizer["Azure Blob storage is Microsoft's object storage solution for the cloud. Blob storage is optimized for storing massive amounts of unstructured data, such as text or binary data."],
            TerraformTemplate.AzureAppService => Localizer["Azure App Service is a fully managed web hosting service for building web apps, mobile back ends, and RESTful APIs. It offers auto-scaling and high availability, supports both Windows and Linux, and enables automated deployments from GitHub, Azure DevOps, or any Git repo."],
            TerraformTemplate.AzurePostgres => Localizer["Azure Database for PostgreSQL is a relational database service based on the open-source Postgres database engine. It's a fully managed database-as-a-service offering that can handle mission-critical workloads with predictable performance, security, high availability, and dynamic scalability."],
            TerraformTemplate.AzureArcGis => Localizer["ArcGIS is a geographic information system (GIS) for working with maps and geographic information. It is used for creating and using maps, compiling geographic data, analyzing mapped information, sharing and discovering geographic information, using maps and geographic information in a range of applications, and managing geographic information in a database."],
            TerraformTemplate.AzureAPI => Localizer["Azure API Management is a fully managed service that enables participants to publish, secure, transform, maintain, and monitor APIs. To use API Management, you must first create an Azure App Service."],
            _ => tool
        };
    }

    private string GetIcon(string tool)
    {
        return tool switch
        {
            TerraformTemplate.AzureDatabricks => SidebarIcons.Databricks,
            TerraformTemplate.AzureStorageBlob => SidebarIcons.Storage,
            TerraformTemplate.AzureAppService => SidebarIcons.WebApp,
            TerraformTemplate.AzurePostgres => SidebarIcons.SqlDatabase,
            TerraformTemplate.AzureArcGis => SidebarIcons.ArcGis,
            TerraformTemplate.AzureAPI => SidebarIcons.Api,
            _ => SidebarIcons.Default
        };
    }

}